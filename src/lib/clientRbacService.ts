import { AzureRole, Operation, LeastPrivilegeInput, LeastPrivilegeResult } from '@/types/rbac';
import { calculateLeastPrivilegedRoles, extractServiceNamespaces, matchesWildcard } from './rbacService';
import { CACHE_TTL_MS, SEARCH } from '@/config/constants';

/**
 * In-memory cache for Azure RBAC data (roles and permissions).
 * Reduces fetch calls and improves UI responsiveness.
 * Cache expires after 6 hours.
 */
let rolesCache: AzureRole[] | null = null;
let permissionsCache: Operation[] | null = null;
let actionsMapCache: Map<string, { name: string; roleCount: number }> | null = null;
let rolesCacheExpiry = 0;
let permissionsCacheExpiry = 0;
let actionsMapCacheExpiry = 0;

/**
 * Transforms Azure action name into user-friendly Operation object.
 * Parses hierarchical action string into provider/resource/operation components.
 *
 * Example: "Microsoft.Storage/storageAccounts/blobServices/read"
 * - provider: "Microsoft.Storage"
 * - resource: "storageAccounts/blobServices"
 * - operation: "read"
 * - displayName: "read storageAccounts/blobServices"
 */
function createOperationFromAction(actionName: string, roleCount: number): Operation {
  const parts = actionName.split('/');
  const provider = parts[0] || '';
  const resource = parts.slice(1, -1).join('/') || '';
  const operation = parts[parts.length - 1] || '';

  return {
    name: actionName,
    displayName: `${operation} ${resource}`.trim() || actionName,
    description: `Used by ${roleCount} role${roleCount > 1 ? 's' : ''}`,
    provider,
    roleCount
  };
}

/**
 * Loads Azure built-in role definitions with extended metadata.
 * Data includes role names, permissions, and privilege scores.
 * Generated by scripts/updateRbacData.ts and cached for 6 hours.
 */
export async function loadRoleDefinitions(): Promise<AzureRole[]> {
  const now = Date.now();

  if (rolesCache && rolesCacheExpiry > now) {
    return rolesCache;
  }

  try {
    const response = await fetch('/data/roles-extended.json');
    if (!response.ok) {
      throw new Error(`Failed to load role definitions: ${response.statusText}`);
    }

    const roles = await response.json() as AzureRole[];
    rolesCache = roles;
    rolesCacheExpiry = now + CACHE_TTL_MS;

    return roles;
  } catch (error) {
    throw new Error(`Failed to load role definitions: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

/**
 * Loads Azure resource provider operations (permissions catalog).
 * This file is optional - if missing, app falls back to extracting actions from roles.
 * Generated by scripts/updateRbacData.ts and cached for 6 hours.
 */
export async function loadPermissions(): Promise<Operation[]> {
  const now = Date.now();

  if (permissionsCache && permissionsCacheExpiry > now) {
    return permissionsCache;
  }

  try {
    const response = await fetch('/data/permissions.json');
    if (!response.ok) {
      if (response.status === 404) {
        console.warn('Permissions file not found - search functionality will be limited');
        return [];
      }
      throw new Error(`Failed to load permissions: ${response.statusText}`);
    }

    const permissions = await response.json() as Operation[];
    permissionsCache = permissions;
    permissionsCacheExpiry = now + CACHE_TTL_MS;

    return permissions;
  } catch (error) {
    console.warn('Failed to load permissions:', error);
    return [];
  }
}

/**
 * Loads pre-computed actions cache from build-time generated file.
 * This avoids expensive runtime wildcard matching computation.
 * Falls back to computing at runtime if cache file is unavailable.
 */
async function loadActionsCache(): Promise<Map<string, { name: string; roleCount: number }> | null> {
  try {
    const response = await fetch('/data/actions-cache.json');
    if (!response.ok) {
      return null;
    }

    const cacheArray = await response.json() as Array<{ key: string; name: string; roleCount: number }>;
    const cacheMap = new Map<string, { name: string; roleCount: number }>();

    for (const entry of cacheArray) {
      cacheMap.set(entry.key, { name: entry.name, roleCount: entry.roleCount });
    }

    return cacheMap;
  } catch (error) {
    console.warn('Failed to load pre-computed actions cache, will compute at runtime:', error);
    return null;
  }
}

/**
 * Fallback: Extracts all unique actions from role definitions.
 * Used when permissions.json is unavailable (Simple mode).
 * Filters out wildcard actions and counts role usage for each action.
 *
 * Improvements:
 * - Case-insensitive deduplication (normalizes to lowercase keys)
 * - Counts ALL roles that grant the permission (including via wildcards)
 * - Prefers canonical casing (most commonly used variant)
 * - Cached for 6 hours to avoid expensive recomputation
 * - First tries to load pre-computed cache from actions-cache.json (fast path)
 * - Falls back to expensive computation only if cache unavailable (slow path)
 */
/**
 * Type definitions for action extraction
 */
type ActionCasingMap = Map<string, Map<string, number>>;
type ExplicitActionRolesMap = Map<string, Set<number>>;
type WildcardPattern = {
  pattern: string;
  roleIndex: number;
  notActions: string[];
  notDataActions: string[];
};

/**
 * Collect explicit (non-wildcard) actions from all roles.
 * Tracks casing variants and which roles have each action.
 */
function collectExplicitActionMetadata(roles: AzureRole[]): {
  actionCasingMap: ActionCasingMap;
  explicitActionRoles: ExplicitActionRolesMap;
} {
  const explicitActionRoles: ExplicitActionRolesMap = new Map();
  const actionCasingMap: ActionCasingMap = new Map();

  for (let roleIndex = 0; roleIndex < roles.length; roleIndex++) {
    const role = roles[roleIndex];
    for (const permission of role.permissions) {
      // Process regular actions
      for (const action of permission.actions) {
        if (action.includes('*')) continue;

        const lowerAction = action.toLowerCase();

        // Track casing variants
        if (!actionCasingMap.has(lowerAction)) {
          actionCasingMap.set(lowerAction, new Map());
        }
        const casingVariants = actionCasingMap.get(lowerAction)!;
        casingVariants.set(action, (casingVariants.get(action) || 0) + 1);

        // Track which roles have this action explicitly
        if (!explicitActionRoles.has(lowerAction)) {
          explicitActionRoles.set(lowerAction, new Set());
        }
        explicitActionRoles.get(lowerAction)!.add(roleIndex);
      }

      // Process data actions
      if (permission.dataActions) {
        for (const dataAction of permission.dataActions) {
          if (dataAction.includes('*')) continue;

          const lowerAction = dataAction.toLowerCase();

          if (!actionCasingMap.has(lowerAction)) {
            actionCasingMap.set(lowerAction, new Map());
          }
          const casingVariants = actionCasingMap.get(lowerAction)!;
          casingVariants.set(dataAction, (casingVariants.get(dataAction) || 0) + 1);

          if (!explicitActionRoles.has(lowerAction)) {
            explicitActionRoles.set(lowerAction, new Set());
          }
          explicitActionRoles.get(lowerAction)!.add(roleIndex);
        }
      }
    }
  }

  return { actionCasingMap, explicitActionRoles };
}

/**
 * Collect all wildcard patterns from roles.
 * Includes wildcards from both actions and dataActions with their respective deny lists.
 * This is typically < 100 patterns vs thousands of explicit actions.
 */
function collectWildcardPatterns(roles: AzureRole[]): WildcardPattern[] {
  const wildcardPatterns: WildcardPattern[] = [];

  for (let roleIndex = 0; roleIndex < roles.length; roleIndex++) {
    const role = roles[roleIndex];
    for (const permission of role.permissions) {
      // Collect wildcard actions
      for (const action of permission.actions) {
        if (action.includes('*')) {
          wildcardPatterns.push({
            pattern: action,
            roleIndex,
            notActions: permission.notActions,
            notDataActions: permission.notDataActions || []
          });
        }
      }

      // Collect wildcard dataActions
      if (permission.dataActions) {
        for (const dataAction of permission.dataActions) {
          if (dataAction.includes('*')) {
            wildcardPatterns.push({
              pattern: dataAction,
              roleIndex,
              notActions: permission.notActions,
              notDataActions: permission.notDataActions || []
            });
          }
        }
      }
    }
  }

  return wildcardPatterns;
}

/**
 * Build the final actions map by combining explicit actions with wildcard matches.
 * For each action, determines the canonical name and counts total roles that grant it.
 */
function buildActionsMap(
  actionCasingMap: ActionCasingMap,
  explicitActionRoles: ExplicitActionRolesMap,
  wildcardPatterns: WildcardPattern[]
): Map<string, { name: string; roleCount: number }> {
  const actionsMap = new Map<string, { name: string; roleCount: number }>();

  for (const [lowerAction, casingVariants] of Array.from(actionCasingMap.entries())) {
    // Choose canonical casing (most commonly used variant)
    let canonicalName = '';
    let maxCount = 0;

    for (const [casing, count] of Array.from(casingVariants.entries())) {
      if (count > maxCount) {
        maxCount = count;
        canonicalName = casing;
      }
    }

    // Start with explicit role indices
    const roleSet = new Set(explicitActionRoles.get(lowerAction) || []);

    // Add roles that grant via wildcards
    for (const { pattern, roleIndex, notActions, notDataActions } of wildcardPatterns) {
      if (matchesWildcard(pattern, canonicalName)) {
        // Check if it's not denied (check both notActions and notDataActions)
        let isDenied = false;

        // Check notActions deny list
        for (const deniedAction of notActions) {
          if (matchesWildcard(deniedAction, canonicalName)) {
            isDenied = true;
            break;
          }
        }

        // Check notDataActions deny list
        if (!isDenied) {
          for (const deniedDataAction of notDataActions) {
            if (matchesWildcard(deniedDataAction, canonicalName)) {
              isDenied = true;
              break;
            }
          }
        }

        if (!isDenied) {
          roleSet.add(roleIndex);
        }
      }
    }

    actionsMap.set(lowerAction, { name: canonicalName, roleCount: roleSet.size });
  }

  return actionsMap;
}

/**
 * Extract all actions from Azure roles and compute role counts for each action.
 * Uses caching and fallback to pre-computed cache for performance.
 */
async function extractActionsFromRoles(): Promise<Map<string, { name: string; roleCount: number }>> {
  const now = Date.now();

  // Return cached data if available and not expired
  if (actionsMapCache && actionsMapCacheExpiry > now) {
    return actionsMapCache;
  }

  // Try loading pre-computed cache first (fast path)
  const precomputedCache = await loadActionsCache();
  if (precomputedCache) {
    actionsMapCache = precomputedCache;
    actionsMapCacheExpiry = now + CACHE_TTL_MS;
    return precomputedCache;
  }

  // Fallback to expensive computation (slow path)
  console.warn('Pre-computed actions cache not available, computing at runtime (this may take a few seconds)...');

  const roles = await loadRoleDefinitions();
  const { actionCasingMap, explicitActionRoles } = collectExplicitActionMetadata(roles);
  const wildcardPatterns = collectWildcardPatterns(roles);
  const actionsMap = buildActionsMap(actionCasingMap, explicitActionRoles, wildcardPatterns);

  // Cache the result
  actionsMapCache = actionsMap;
  actionsMapCacheExpiry = now + CACHE_TTL_MS;

  return actionsMap;
}

/**
 * Searches Azure operations by query string.
 * Two modes:
 * 1. Advanced: Searches permissions.json (full operation metadata)
 * 2. Simple: Falls back to extracting actions from roles (minimal metadata)
 *
 * Searches across name, display name, and description fields.
 * Requires minimum 2 characters.
 */
export async function searchOperations(query: string): Promise<Operation[]> {
  if (!query || query.trim().length < SEARCH.MIN_QUERY_LENGTH) {
    return [];
  }

  const permissions = await loadPermissions();

  // Advanced mode: Use full permissions catalog if available
  if (permissions.length > 0) {
    const queryLower = query.toLowerCase();
    return permissions.filter(operation => {
      const nameLower = operation.name.toLowerCase();
      const displayNameLower = operation.displayName?.toLowerCase() || '';
      const descriptionLower = operation.description?.toLowerCase() || '';

      return (
        nameLower.includes(queryLower) ||
        displayNameLower.includes(queryLower) ||
        descriptionLower.includes(queryLower)
      );
    });
  }

  // Simple mode fallback: Extract from roles
  const actionsMap = await extractActionsFromRoles();
  const queryLower = query.toLowerCase();
  const results: Operation[] = [];

  for (const [lowerActionKey, actionData] of Array.from(actionsMap.entries())) {
    // actionsMap keys are now lowercase, so compare directly
    if (lowerActionKey.includes(queryLower)) {
      results.push(createOperationFromAction(actionData.name, actionData.roleCount));
    }
  }

  // Sort by role count (most used first)
  return results.sort((a, b) => {
    const aCount = a.roleCount ?? 0;
    const bCount = b.roleCount ?? 0;
    return bCount - aCount;
  });
}

/** Returns sorted list of all unique Azure service namespaces (e.g., "Microsoft.Storage") */
export async function getServiceNamespaces(): Promise<string[]> {
  const roles = await loadRoleDefinitions();
  return extractServiceNamespaces(roles);
}

/**
 * Retrieves all actions for a specific service namespace.
 * Example: "Microsoft.Storage" returns all Storage-related actions.
 * Results sorted alphabetically by action name.
 */
export async function getActionsByService(serviceNamespace: string): Promise<Operation[]> {
  if (!serviceNamespace) {
    return [];
  }

  const actionsMap = await extractActionsFromRoles();
  const namespaceLower = serviceNamespace.toLowerCase();
  const results: Operation[] = [];

  for (const [lowerActionKey, actionData] of Array.from(actionsMap.entries())) {
    // actionsMap keys are now lowercase, so compare directly
    if (lowerActionKey.startsWith(namespaceLower + '/')) {
      results.push(createOperationFromAction(actionData.name, actionData.roleCount));
    }
  }

  return results.sort((a, b) => a.name.toLowerCase().localeCompare(b.name.toLowerCase()));
}

/**
 * Calculates least privileged roles for given permissions.
 * Wrapper that loads roles and delegates to rbacService logic.
 */
export async function calculateLeastPrivilege(input: LeastPrivilegeInput): Promise<LeastPrivilegeResult[]> {
  const roles = await loadRoleDefinitions();
  return calculateLeastPrivilegedRoles(roles, input);
}

/**
 * Pre-loads and caches the actions map in the background.
 * Call this on page load to avoid UI freezing when user first selects a service.
 * Subsequent calls will return immediately if cache is warm.
 */
export async function preloadActionsCache(): Promise<void> {
  try {
    await extractActionsFromRoles();
  } catch (error) {
    console.warn('Failed to preload actions cache:', error);
  }
}
