import {
  EntraIDRole,
  EntraIDLeastPrivilegeInput,
  EntraIDLeastPrivilegeResult
} from '@/types/rbac';
import { matchesWildcard } from './rbacService';
import { CACHE_TTL_MS } from '@/config/constants';

/**
 * In-memory cache for Entra ID role data.
 * Reduces fetch calls and improves UI responsiveness.
 * Cache expires after 6 hours.
 */
let entraIdRolesCache: EntraIDRole[] | null = null;
let entraIdRolesCacheExpiry = 0;
let entraIdActionsMapCache: Map<string, { name: string; roleCount: number }> | null = null;
let entraIdActionsMapCacheExpiry = 0;
type EntraIdRolesDataStatus = 'unknown' | 'missing' | 'available';
let entraIdRolesDataStatus: EntraIdRolesDataStatus = 'unknown';

export function getEntraIDRolesDataStatus(): EntraIdRolesDataStatus {
  return entraIdRolesDataStatus;
}

/**
 * Loads Entra ID role definitions with extended metadata.
 * Data includes role names, permissions, and privilege scores.
 * Generated by scripts/updateRbacData.ts and cached for 6 hours.
 */
export async function loadEntraIDRoles(): Promise<EntraIDRole[]> {
  const now = Date.now();

  if (entraIdRolesCache && entraIdRolesCacheExpiry > now) {
    return entraIdRolesCache;
  }

  try {
    const response = await fetch('/data/entraid-roles.json');
    if (!response.ok) {
      if (response.status === 404) {
        // File doesn't exist yet - user needs to run npm run fetch-entraid-roles
        console.warn('Entra ID roles data not found. Run: npm run fetch-entraid-roles');
        entraIdRolesDataStatus = 'missing';
        return [];
      }
      throw new Error(`Failed to load Entra ID roles: ${response.statusText}`);
    }

    const roles = await response.json() as EntraIDRole[];
    entraIdRolesCache = roles;
    entraIdRolesCacheExpiry = now + CACHE_TTL_MS;
    entraIdRolesDataStatus = 'available';

    return roles;
  } catch (error) {
    if (error instanceof Error && error.message.includes('404')) {
      entraIdRolesDataStatus = 'missing';
      return [];
    }
    throw new Error(`Failed to load Entra ID roles: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

/**
 * Checks if an Entra ID role has a specific permission.
 * Supports wildcard matching for resource actions.
 *
 * Example patterns:
 * - microsoft.directory/users/password/update (exact match)
 * - microsoft.directory/* (all directory actions)
 * - microsoft.directory/users/* (all user actions)
 */
function hasEntraIDPermission(role: EntraIDRole, requiredAction: string): boolean {
  for (const permission of role.rolePermissions) {
    // Check allowed actions
    for (const allowedAction of permission.allowedResourceActions) {
      if (matchesWildcard(allowedAction, requiredAction)) {
        // Also check it's not in excluded actions
        const isExcluded = permission.excludedResourceActions?.some(
          excluded => matchesWildcard(excluded, requiredAction)
        ) || false;

        if (!isExcluded) {
          return true;
        }
      }
    }
  }

  return false;
}

/**
 * Calculates total permission count for an Entra ID role.
 * Used for privilege scoring (lower is more restrictive).
 *
 * Scoring weights:
 * - Full wildcard (*): 10,000 points (extremely broad)
 * - Wildcard patterns: weighted based on specificity
 * - Specific actions: 1 point each
 */
export function calculateEntraIDPermissionCount(role: EntraIDRole): number {
  let count = 0;

  for (const permission of role.rolePermissions) {
    for (const action of permission.allowedResourceActions) {
      if (action === '*') {
        count += 10000;
      } else if (action.includes('*')) {
        // Count wildcard segments
        const segments = action.split('/').filter(s => s === '*').length;
        count += 100 * segments;
      } else {
        count += 1;
      }
    }

    // Subtract points for excluded actions (they restrict the role)
    if (permission.excludedResourceActions) {
      for (const excluded of permission.excludedResourceActions) {
        if (excluded === '*') {
          count -= 1000;
        } else if (excluded.includes('*')) {
          count -= 10;
        } else {
          count -= 1;
        }
      }
    }
  }

  return Math.max(count, 1); // Minimum of 1
}

/**
 * Calculates namespace relevance for an Entra ID role.
 * Higher score = role is more specific to the requested actions.
 *
 * Example: "User Administrator" gets high score for microsoft.directory/users/* actions
 */
function calculateEntraIDNamespaceRelevance(role: EntraIDRole, requiredActions: string[]): number {
  let relevanceScore = 0;

  // Extract unique namespaces from required actions
  const requiredNamespaces = new Set(
    requiredActions.map(action => {
      const parts = action.split('/');
      return parts[0]; // e.g., "microsoft.directory"
    })
  );

  // Check role's allowed actions for namespace matches
  for (const permission of role.rolePermissions) {
    for (const allowedAction of permission.allowedResourceActions) {
      // Broad wildcard penalty
      if (allowedAction === '*' || allowedAction === '*/') {
        relevanceScore -= 50;
        continue;
      }

      // Check namespace match
      const actionNamespace = allowedAction.split('/')[0];
      if (requiredNamespaces.has(actionNamespace)) {
        relevanceScore += 100;
      }
    }
  }

  // Bonus for role name matching namespace
  const roleNameLower = role.displayName.toLowerCase();
  for (const action of requiredActions) {
    const parts = action.split('/');
    if (parts.length >= 2) {
      const resourceType = parts[1]; // e.g., "users", "groups", "applications"
      if (roleNameLower.includes(resourceType)) {
        relevanceScore += 200;
        break;
      }
    }
  }

  return relevanceScore;
}

/**
 * Finds Entra ID roles that satisfy all required permissions, ranked by privilege level.
 * Returns roles sorted by least privileged first (exact matches prioritized).
 *
 * Ranking logic:
 * 1. Exact matches first (roles with only the required permissions)
 * 2. Namespace relevance (higher = more specific to the domain)
 * 3. Permission count (lower = more restrictive)
 */
export function calculateLeastPrivilegedEntraIDRoles(
  roles: EntraIDRole[],
  input: EntraIDLeastPrivilegeInput
): EntraIDLeastPrivilegeResult[] {
  const results: EntraIDLeastPrivilegeResult[] = [];

  for (const role of roles) {
    // Skip disabled roles
    if (!role.isEnabled) {
      continue;
    }

    const matchingActions: string[] = [];

    // Check if role has all required actions
    let hasAllActions = true;
    for (const requiredAction of input.requiredActions) {
      if (hasEntraIDPermission(role, requiredAction)) {
        matchingActions.push(requiredAction);
      } else {
        hasAllActions = false;
        break;
      }
    }

    // Only include roles that satisfy all requirements
    if (hasAllActions) {
      const permissionCount = role.permissionCount || calculateEntraIDPermissionCount(role);

      // Detect exact matches
      const isExactMatch =
        matchingActions.length === input.requiredActions.length &&
        permissionCount === input.requiredActions.length;

      results.push({
        role,
        matchingActions,
        permissionCount,
        isExactMatch
      });
    }
  }

  // Sort by: exact matches first, then relevance, then permission count
  results.sort((a, b) => {
    // Exact matches always come first
    if (a.isExactMatch && !b.isExactMatch) return -1;
    if (!a.isExactMatch && b.isExactMatch) return 1;

    // Calculate namespace relevance
    const relevanceA = calculateEntraIDNamespaceRelevance(a.role, input.requiredActions);
    const relevanceB = calculateEntraIDNamespaceRelevance(b.role, input.requiredActions);

    // Higher relevance = better match (descending)
    if (relevanceA !== relevanceB) {
      return relevanceB - relevanceA;
    }

    // If relevance is equal, use permission count (ascending)
    return a.permissionCount - b.permissionCount;
  });

  return results;
}

/**
 * Calculates least privileged Entra ID roles for given permissions.
 * Wrapper that loads roles and delegates to calculation logic.
 */
export async function calculateLeastPrivilegeEntraID(
  input: EntraIDLeastPrivilegeInput
): Promise<EntraIDLeastPrivilegeResult[]> {
  const roles = await loadEntraIDRoles();
  return calculateLeastPrivilegedEntraIDRoles(roles, input);
}

/**
 * Extracts unique service namespaces from all Entra ID roles.
 * Returns namespaces like "microsoft.directory", "microsoft.azure", etc.
 */
export async function getEntraIDNamespaces(): Promise<string[]> {
  const roles = await loadEntraIDRoles();
  const namespaceSet = new Set<string>();

  for (const role of roles) {
    for (const permission of role.rolePermissions) {
      for (const action of permission.allowedResourceActions) {
        const namespace = action.split('/')[0];
        if (namespace && namespace !== '*') {
          namespaceSet.add(namespace);
        }
      }
    }
  }

  return Array.from(namespaceSet).sort();
}

/**
 * Extracts all unique actions from Entra ID roles.
 * Returns a map of action name to role count (how many roles grant this action).
 */
export async function extractActionsFromEntraIDRoles(): Promise<Map<string, { name: string; roleCount: number }>> {
  const now = Date.now();

  // Return cached data if available and fresh
  if (entraIdActionsMapCache && entraIdActionsMapCacheExpiry > now) {
    return entraIdActionsMapCache;
  }

  const roles = await loadEntraIDRoles();
  const actionsMap = new Map<string, { name: string; roleCount: number }>();

  for (const role of roles) {
    if (!role.isEnabled) continue;

    for (const permission of role.rolePermissions) {
      for (const action of permission.allowedResourceActions) {
        // Skip wildcards for action enumeration
        if (action.includes('*')) continue;

        const key = action.toLowerCase();
        const existing = actionsMap.get(key);

        if (existing) {
          existing.roleCount++;
        } else {
          actionsMap.set(key, {
            name: action,
            roleCount: 1
          });
        }
      }
    }
  }

  entraIdActionsMapCache = actionsMap;
  entraIdActionsMapCacheExpiry = now + CACHE_TTL_MS;

  return actionsMap;
}

/**
 * Gets all actions for a specific Entra ID namespace.
 * Example: "microsoft.directory" returns all directory actions
 */
export async function getEntraIDActionsByNamespace(namespace: string): Promise<string[]> {
  const actionsMap = await extractActionsFromEntraIDRoles();
  const results: string[] = [];
  const namespaceLower = namespace.toLowerCase();

  for (const [key, actionData] of Array.from(actionsMap.entries())) {
    if (key.startsWith(namespaceLower + '/')) {
      results.push(actionData.name);
    }
  }

  return results.sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
}

/**
 * Searches Entra ID actions by query string.
 * Returns actions matching the query in name or namespace.
 */
export async function searchEntraIDActions(query: string): Promise<string[]> {
  if (query.length < 2) {
    return [];
  }

  const actionsMap = await extractActionsFromEntraIDRoles();
  const results: string[] = [];
  const queryLower = query.toLowerCase();

  for (const [, actionData] of Array.from(actionsMap.entries())) {
    if (actionData.name.toLowerCase().includes(queryLower)) {
      results.push(actionData.name);
    }
  }

  return results
    .sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()))
    .slice(0, 100); // Limit to 100 results
}

/**
 * Pre-loads and caches the Entra ID actions map in the background.
 */
export async function preloadEntraIDActionsCache(): Promise<void> {
  try {
    await extractActionsFromEntraIDRoles();
  } catch (error) {
    console.warn('Failed to preload Entra ID actions cache:', error);
  }
}
