import { AzureRole, Operation, LeastPrivilegeInput, LeastPrivilegeResult } from '@/types/rbac';
import { calculateLeastPrivilegedRoles, extractServiceNamespaces } from './rbacService';
import { CACHE_TTL_MS, SEARCH } from '@/config/constants';
import { collectExplicitActionMetadata, collectWildcardPatterns, buildActionsMap } from './rbacAggregation';

/**
 * In-memory cache for Azure RBAC data (roles and permissions).
 * Reduces fetch calls and improves UI responsiveness.
 * Cache expires after 6 hours.
 */
let rolesCache: AzureRole[] | null = null;
let permissionsCache: Operation[] | null = null;
let actionsMapCache: Map<string, { name: string; roleCount: number }> | null = null;
let rolesCacheExpiry = 0;
let permissionsCacheExpiry = 0;
let actionsMapCacheExpiry = 0;

/**
 * Transforms Azure action name into user-friendly Operation object.
 * Parses hierarchical action string into provider/resource/operation components.
 *
 * Example: "Microsoft.Storage/storageAccounts/blobServices/read"
 * - provider: "Microsoft.Storage"
 * - resource: "storageAccounts/blobServices"
 * - operation: "read"
 * - displayName: "read storageAccounts/blobServices"
 */
function createOperationFromAction(actionName: string, roleCount: number): Operation {
  const parts = actionName.split('/');
  const provider = parts[0] || '';
  const resource = parts.slice(1, -1).join('/') || '';
  const operation = parts[parts.length - 1] || '';

  return {
    name: actionName,
    displayName: `${operation} ${resource}`.trim() || actionName,
    description: `Used by ${roleCount} role${roleCount > 1 ? 's' : ''}`,
    provider,
    roleCount
  };
}

/**
 * Loads Azure built-in role definitions with extended metadata.
 * Data includes role names, permissions, and privilege scores.
 * Generated by scripts/updateRbacData.ts and cached for 6 hours.
 */
export async function loadRoleDefinitions(): Promise<AzureRole[]> {
  const now = Date.now();

  if (rolesCache && rolesCacheExpiry > now) {
    return rolesCache;
  }

  try {
    const response = await fetch('/data/roles-extended.json');
    if (!response.ok) {
      throw new Error(`Failed to load role definitions: ${response.statusText}`);
    }

    const roles = await response.json() as AzureRole[];
    rolesCache = roles;
    rolesCacheExpiry = now + CACHE_TTL_MS;

    return roles;
  } catch (error) {
    throw new Error(`Failed to load role definitions: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

/**
 * Loads Azure resource provider operations (permissions catalog).
 * This file is optional - if missing, app falls back to extracting actions from roles.
 * Generated by scripts/updateRbacData.ts and cached for 6 hours.
 */
export async function loadPermissions(): Promise<Operation[]> {
  const now = Date.now();

  if (permissionsCache && permissionsCacheExpiry > now) {
    return permissionsCache;
  }

  try {
    const response = await fetch('/data/permissions.json');
    if (!response.ok) {
      if (response.status === 404) {
        console.warn('Permissions file not found - search functionality will be limited');
        return [];
      }
      throw new Error(`Failed to load permissions: ${response.statusText}`);
    }

    const permissions = await response.json() as Operation[];
    permissionsCache = permissions;
    permissionsCacheExpiry = now + CACHE_TTL_MS;

    return permissions;
  } catch (error) {
    console.warn('Failed to load permissions:', error);
    return [];
  }
}

/**
 * Loads pre-computed actions cache from build-time generated file.
 * This avoids expensive runtime wildcard matching computation.
 * Falls back to computing at runtime if cache file is unavailable.
 */
async function loadActionsCache(): Promise<Map<string, { name: string; roleCount: number }> | null> {
  try {
    const response = await fetch('/data/actions-cache.json');
    if (!response.ok) {
      return null;
    }

    const cacheArray = await response.json() as Array<{ key: string; name: string; roleCount: number }>;
    const cacheMap = new Map<string, { name: string; roleCount: number }>();

    for (const entry of cacheArray) {
      cacheMap.set(entry.key, { name: entry.name, roleCount: entry.roleCount });
    }

    return cacheMap;
  } catch (error) {
    console.warn('Failed to load pre-computed actions cache, will compute at runtime:', error);
    return null;
  }
}

/**
 * Fallback: Extracts all unique actions from role definitions.
 * Used when permissions.json is unavailable (Simple mode).
 * Filters out wildcard actions and counts role usage for each action.
 *
 * Improvements:
 * - Case-insensitive deduplication (normalizes to lowercase keys)
 * - Counts ALL roles that grant the permission (including via wildcards)
 * - Prefers canonical casing (most commonly used variant)
 * - Cached for 6 hours to avoid expensive recomputation
 * - First tries to load pre-computed cache from actions-cache.json (fast path)
 * - Falls back to expensive computation only if cache unavailable (slow path)
 */
/**
 * Extract all actions from Azure roles and compute role counts for each action.
 * Uses caching and fallback to pre-computed cache for performance.
 */
async function extractActionsFromRoles(): Promise<Map<string, { name: string; roleCount: number }>> {
  const now = Date.now();

  // Return cached data if available and not expired
  if (actionsMapCache && actionsMapCacheExpiry > now) {
    return actionsMapCache;
  }

  // Try loading pre-computed cache first (fast path)
  const precomputedCache = await loadActionsCache();
  if (precomputedCache) {
    actionsMapCache = precomputedCache;
    actionsMapCacheExpiry = now + CACHE_TTL_MS;
    return precomputedCache;
  }

  // Fallback to expensive computation (slow path)
  console.warn('Pre-computed actions cache not available, computing at runtime (this may take a few seconds)...');

  const roles = await loadRoleDefinitions();
  const { actionCasingMap, explicitActionRoles } = collectExplicitActionMetadata(roles);
  const wildcardPatterns = collectWildcardPatterns(roles);
  const actionsMap = buildActionsMap(actionCasingMap, explicitActionRoles, wildcardPatterns);

  // Cache the result
  actionsMapCache = actionsMap;
  actionsMapCacheExpiry = now + CACHE_TTL_MS;

  return actionsMap;
}

/**
 * Searches Azure operations by query string.
 * Two modes:
 * 1. Advanced: Searches permissions.json (full operation metadata)
 * 2. Simple: Falls back to extracting actions from roles (minimal metadata)
 *
 * Searches across name, display name, and description fields.
 * Requires minimum 2 characters.
 */
export async function searchOperations(query: string): Promise<Operation[]> {
  if (!query || query.trim().length < SEARCH.MIN_QUERY_LENGTH) {
    return [];
  }

  const permissions = await loadPermissions();

  // Advanced mode: Use full permissions catalog if available
  if (permissions.length > 0) {
    const queryLower = query.toLowerCase();
    return permissions.filter(operation => {
      const nameLower = operation.name.toLowerCase();
      const displayNameLower = operation.displayName?.toLowerCase() || '';
      const descriptionLower = operation.description?.toLowerCase() || '';

      return (
        nameLower.includes(queryLower) ||
        displayNameLower.includes(queryLower) ||
        descriptionLower.includes(queryLower)
      );
    });
  }

  // Simple mode fallback: Extract from roles
  const actionsMap = await extractActionsFromRoles();
  const queryLower = query.toLowerCase();
  const results: Operation[] = [];

  for (const [lowerActionKey, actionData] of Array.from(actionsMap.entries())) {
    // actionsMap keys are now lowercase, so compare directly
    if (lowerActionKey.includes(queryLower)) {
      results.push(createOperationFromAction(actionData.name, actionData.roleCount));
    }
  }

  // Sort by role count (most used first)
  return results.sort((a, b) => {
    const aCount = a.roleCount ?? 0;
    const bCount = b.roleCount ?? 0;
    return bCount - aCount;
  });
}

/** Returns sorted list of all unique Azure service namespaces (e.g., "Microsoft.Storage") */
export async function getServiceNamespaces(): Promise<string[]> {
  const roles = await loadRoleDefinitions();
  return extractServiceNamespaces(roles);
}

/**
 * Retrieves all actions for a specific service namespace.
 * Example: "Microsoft.Storage" returns all Storage-related actions.
 * Results sorted alphabetically by action name.
 */
export async function getActionsByService(serviceNamespace: string): Promise<Operation[]> {
  if (!serviceNamespace) {
    return [];
  }

  const actionsMap = await extractActionsFromRoles();
  const namespaceLower = serviceNamespace.toLowerCase();
  const results: Operation[] = [];

  for (const [lowerActionKey, actionData] of Array.from(actionsMap.entries())) {
    // actionsMap keys are now lowercase, so compare directly
    if (lowerActionKey.startsWith(namespaceLower + '/')) {
      results.push(createOperationFromAction(actionData.name, actionData.roleCount));
    }
  }

  return results.sort((a, b) => a.name.toLowerCase().localeCompare(b.name.toLowerCase()));
}

/**
 * Calculates least privileged roles for given permissions.
 * Wrapper that loads roles and delegates to rbacService logic.
 */
export async function calculateLeastPrivilege(input: LeastPrivilegeInput): Promise<LeastPrivilegeResult[]> {
  const roles = await loadRoleDefinitions();
  return calculateLeastPrivilegedRoles(roles, input);
}

/**
 * Pre-loads and caches the actions map in the background.
 * Call this on page load to avoid UI freezing when user first selects a service.
 * Subsequent calls will return immediately if cache is warm.
 */
export async function preloadActionsCache(): Promise<void> {
  try {
    await extractActionsFromRoles();
  } catch (error) {
    console.warn('Failed to preload actions cache:', error);
  }
}
